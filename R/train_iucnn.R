#' Train an IUCNN Model
#'
#'Trains an IUCNN model based on a data,frame of features,
#'for instance generated by \code{\link{geo_features}}, |link{clim_features}, and \code{\link{biome_features}},
#'and a dataset of labels, (i.e. IUCNN classes) for each species.
#'
#'
#'
#'@param x a data.set, containing a column "species" with the species names, and
#'subsequent columns with different features, in the same order as used for \code{\link{predict_iucnn}}.
#'@param labels a data.frame with two columns, first "species" with the species name,
#'second "labels with the labels (i.e. IUCN categories).
#'@param path_to_output character string. The path to the location
#'where the IUCNN model shall be saved
#'@param model_name character string. The name used to save the trained model.
#'@param validation_split numeric. The fraction of the input data used as validation set.
#'@param test_fraction numeric. The fraction of the input data used as test set.
#'@param seed reset the python random seed.
#'@param max_epochs integer. The maximum number of epochs.
#'@param n_layers numeric vector with length of at least one. The vector quantifies the number of nodes
#'used in each hidden layer of the neural network. This also implicitly specifies the number of hidden
#'layers. For example, n_layers = c(60, 10) defines a model with two hidden layers with 60 and 10 nodes
#' respectively. Note that the number of nodes in the output layer is automatically determined based on
#'the number of unique labels in the training set.
#'@param use_bias integer (1/0). Specifies if a bias node is used in the first hidden layer.
#'@param act_f character string. Specifies the activation function should be used in the hidden layers.
#'Available options are: "relu" (default), "tanh", "sigmoid"
#'@param patience integer. Number of epochs with no improvement after which training will be stopped.
#'
#'
#'@note See \code{vignette("Approximate_IUCN_Red_List_assessments_with_IUCNN")} for a
#'tutorial on how to run IUCNN.
#'
#'@return a folder in the working directory (or as specified with path_to_output) with the trained model,
#'for use by \code{\link{predict_iucnn}}.
#'
#' @keywords Prediction

#' @examples
#'\dontrun{
#'dat <- data.frame(species = c("A", "B")
#'                 decimallongitude = runif (200,-5,5),
#'                 decimallatitude = runif (200,-5,5))
#'labels <- c(1,0)
#'
#'train_feat <- geo_features(dat)
#'
#'not_eval <- data.frame(species = c(A", "B")
#'                 decimallongitude = runif (200,-5,5),
#'                 decimallatitude = runif (200,-5,5))
#'
#'predict_feat <- geo_features(not_eval)
#'
#'train_iucnn(x = train_feat,
#'            label = labels)
#'
#'
#'predict_iucnn(x = predict_feat,
#'              model_dir = iuc_nn_model")
#'}
#'
#'
#' @export
#' @importFrom reticulate source_python
#' @importFrom magrittr %>%
#' @importFrom dplyr select left_join mutate
#' @importFrom stats complete.cases


train_iucnn <- function(x,
                        labels,
                        path_to_output=".",
                        model_name = "iuc_nn_model",
                        validation_split = 0.1,
                        test_fraction = 0.1,
                        seed = 1234,
                        max_epochs = 1000,
                        n_layers = c(60,60,20),
                        use_bias = 1,
                        act_f = "relu",
                        patience = 10,
                        randomize_instances = TRUE,
                        mode='classification',
                        rescale_features = FALSE,
                        return_categorical = FALSE,
                        plot_training_stats = TRUE,
                        plot_labels_against_features = FALSE){

  # Check input
  if(!"species" %in% names(x)){
    stop("species column not found in x.
         The features input need a column named 'species'
         with the species names matching those in labels")
  }

  if(!"species" %in% names(labels)){
    stop("species column not found in labels.
         The label input need a column named 'species'
         with the species names matching those in x")
  }

  if(!"species" %in% names(labels)){
    stop("labels column not found in labels.
         The label input need a column named 'labels'")
  }

  # merge speces and labels to match order
  tmp.in <- left_join(x, labels, by = "species")

  if(nrow(tmp.in) != nrow(x)){
    mis <- x$species[!x$species %in% tmp$species]
    warning("Labels for species not found, species removed.\n", paste(mis, "\n"))
  }

  if(nrow(tmp.in) != nrow(labels)){
    mis <- labels$species[!labels$species %in% tmp$species]
    warning("Labels for species not found, species removed.\n", paste(mis, "\n"))
  }

  # complete cases only
  tmp <- tmp.in[complete.cases(tmp.in),]

  if(nrow(tmp) != nrow(tmp.in)){
    mis <- tmp.in[!complete.cases(tmp.in),]
    warning("Information for species was incomplete, species removed\n", paste(mis$species, "\n"))
  }

  # prepare input data for the python function
  dataset <- tmp %>%
    dplyr::select(-.data$species, -.data$labels)

  labels <- tmp %>%
    dplyr::select(labels)

  # prepare labels to start at 0
  if(min(labels$labels) != 0){
    warning(sprintf("Labels need to start at 0. Labels substracted with %s", min(labels$labels)))

    labels <-  labels %>%
      dplyr::mutate(labels = .data$labels - min(.data$labels))
  }

  if (TRUE %in% startsWith(names(tmp),'rescaled_labels')){
    colname = names(tmp)[startsWith(names(tmp),'rescaled_labels')]
    nlab = as.integer(str_split(colname,'_')[[1]][4])
    lab_range = as.numeric(str_split(colname,'_')[[1]][6])
    rescaled_labels = as.numeric(tmp[[colname]])
    dataset = dataset[,1:length(names(dataset))-1] #drop the last column which contains the rescaled labels
  }else{
    rescaled_labels = labels
    nlab = 0
    lab_range = 0
  }


  # labels <- labels %>%
  #   dplyr::mutate(labels = .data$labels )

  # source python function
  reticulate::source_python(system.file("python", "IUCNN_train.py", package = "IUCNN"))

  #write.table(as.matrix(dataset),'manual_tests/features_tutorial_data.txt',sep='\t',quote=FALSE,row.names=FALSE)
  #write.table(as.matrix(labels),'manual_tests/labels_tutorial_data.txt',sep='\t',quote=FALSE,row.names=FALSE)
  #write.table(as.matrix(rescaled_labels),'manual_tests/rescaled_labels_tutorial_data.txt',sep='\t',quote=FALSE,row.names=FALSE)

  # run model via python script
  res = iucnn_train(dataset = as.matrix(dataset),
                    labels = as.matrix(labels),
                    rescaled_labels = as.matrix(rescaled_labels),
                    path_to_output = path_to_output,
                    model_name = model_name,
                    validation_split = validation_split,
                    test_fraction = test_fraction,
                    seed = as.integer(seed),
                    verbose = 0,
                    n_labels = nlab,
                    lab_range = lab_range,
                    max_epochs = as.integer(max_epochs),
                    n_layers = as.list(n_layers),
                    use_bias = use_bias,
                    act_f = act_f,
                    patience = patience,
                    randomize_instances = as.integer(randomize_instances),
                    mode = mode,
                    rescale_features = rescale_features,
                    return_categorical = return_categorical,
                    plot_training_stats = plot_training_stats,
                    plot_labels_against_features = plot_labels_against_features
                    )

  named_res = NULL
  named_res$test_labels <- as.vector(res[[1]])
  named_res$test_predictions <- as.vector(res[[2]])
  named_res$training_loss  <- res[[3]][1]
  named_res$training_accuracy  <- res[[3]][2]
  named_res$validation_loss  <- res[[3]][3]
  named_res$validation_accuracy  <- res[[3]][4]
  named_res$test_loss  <- res[[3]][5]
  named_res$test_accuracy <- res[[3]][6]

  return(named_res)
}
